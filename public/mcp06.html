<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Agent Coordinator (MCP Server)</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f0f0f0; color: #333; }
        .my-main-container { max-width: 900px; margin: 0 auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
        h1, h2, h3 { margin-top: 0; margin-bottom: 15px; }
        .my-log-box, .my-client-list-box { border: 1px solid #eee; background-color: #fafafa; padding: 10px; height: 250px; overflow-y: auto; margin-bottom: 15px; border-radius: 4px; font-size: 0.9em; white-space: pre-wrap; word-break: break-word; }
        button { padding: 10px 15px; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%; margin-top: 10px; }
        button:hover { background-color: #0056b3; }
        .my-client-item { margin-bottom: 5px; }
        .my-client-item strong { color: #0056b3; }
    </style>
</head>
<body>
    <div class="my-main-container">
        <h2>Model Context Protocol (MCP Server) for client-side AI- Agents</h2>
        <p>Note: This is a simulated coordinator using Browser's BroadcastChannel. Each "LLM Agent" will run in a separate tab. For truly distributed agents across different computers, a Node.js WebSocket server would be required.</p>
        <button id="my-spawn-client-button">Spawn New LLM Agent Client Tab</button>

        <h3>My Connected Agents (<span id="my-connected-clients-count">0</span>)</h3>
        <div id="my-client-list" class="my-client-list-box">
            <p style="color: gray; font-style: italic;">No agents connected yet.</p>
        </div>
        <h3>My Coordinator Logs</h3>
        <div id="my-server-logs" class="my-log-box"></div>
    </div>

    <script type="module">
        // --- My Global Constants ---
        const MY_CHANNEL_NAME = 'my_mcp_channel';

        // --- My Agent Coordinator Logic ---
        class MyAgentCoordinator {
            myClients = new Map(); // agentId -> { id, name, status }
            myLogs = [];
            myLogListeners = [];
            myClientUpdateListeners = [];
            myBroadcastChannel;

            constructor() {
                this.myAddLog('My Agent Coordinator started (simulated, awaiting agent connections).');

                this.myBroadcastChannel = new BroadcastChannel(MY_CHANNEL_NAME);
                this.myBroadcastChannel.onmessage = this.myHandleIncomingMessage.bind(this);

                // Add a listener for when the coordinator page is closed or reloaded
                window.addEventListener('beforeunload', () => {
                    this.myBroadcastMessageToClients('COORDINATOR_SHUTDOWN', { reason: 'Coordinator tab closing or reloading.' });
                    this.myAddLog('My Coordinator is shutting down. Notifying agents.');
                    this.myBroadcastChannel.close(); // Close the channel
                });
            }

            myAddLog(myMessage) {
                const myTimestamp = new Date().toLocaleTimeString();
                const myLogEntry = `[${myTimestamp}] COORDINATOR: ${myMessage}`;
                this.myLogs.push(myLogEntry);
                this.myLogListeners.forEach(myListener => myListener(myLogEntry));
            }

            // Sends a message to a specific agent ID or broadcasts to all
            mySendMessage(myTargetId, myType, myPayload) {
                const myMessage = {
                    source: 'coordinator',
                    senderId: 'coordinator',
                    type: myType,
                    targetId: myTargetId,
                    payload: myPayload,
                    timestamp: new Date().toISOString()
                };
                this.myBroadcastChannel.postMessage(myMessage);
            }

            // Broadcasts a message to all connected agents
            myBroadcastMessageToClients(myType, myPayload) {
                this.mySendMessage('broadcast', myType, myPayload);
            }

            async myHandleIncomingMessage(myEvent) {
                const myMsg = myEvent.data;
                if (myMsg.source !== 'agent') {
                    // Ignore messages not from agents
                    return;
                }

                this.myAddLog(`Received message from agent ${myMsg.senderId} (${myMsg.type})`);

                switch (myMsg.type) {
                    case 'AGENT_CONNECT':
                        const myRequestedName = myMsg.payload.requestedName;
                        const myAgentNameTaken = Array.from(this.myClients.values()).some(myC => myC.name === myRequestedName);

                        if (myAgentNameTaken) {
                            this.myAddLog(`Connection rejected for ${myMsg.senderId}: Name "${myRequestedName}" is already taken.`);
                            this.mySendMessage(myMsg.senderId, 'COORDINATOR_REJECTED_CONNECTION', { reason: `Name "${myRequestedName}" is already taken.` });
                        } else {
                            const myNewClient = {
                                id: myMsg.senderId,
                                name: myRequestedName || myMsg.senderId,
                                status: 'connected'
                            };
                            this.myClients.set(myMsg.senderId, myNewClient);
                            this.myAddLog(`Agent ${myNewClient.id} (${myNewClient.name}) connected.`);
                            this.mySendMessage(myMsg.senderId, 'COORDINATOR_ACCEPTED_CONNECTION', { assignedName: myNewClient.name });
                            this.myUpdateClientListAndNotify();
                            this.myBroadcastMessageToClients('COORDINATOR_BROADCAST_MESSAGE', { senderName: 'Coordinator', text: `${myNewClient.name} has joined the agent swarm.` });
                        }
                        break;

                    case 'USER_QUERY':
                        // Simulate routing a user query. In a real system, you'd route to a specific agent
                        // or initiate a complex multi-agent workflow.
                        const myQueryText = myMsg.payload.query;
                        const mySendingAgent = this.myClients.get(myMsg.senderId);
                        this.myAddLog(`User Query from ${mySendingAgent ? mySendingAgent.name : myMsg.senderId}: "${myQueryText}"`);

                        // Example: Route to a specific agent if it exists
                        // if (this.myClients.has('specific-agent-id')) {
                        //     this.mySendMessage('specific-agent-id', 'PROCESS_QUERY', { query: myQueryText });
                        // } else {
                            this.myBroadcastMessageToClients('COORDINATOR_BROADCAST_MESSAGE', {
                                senderName: mySendingAgent ? mySendingAgent.name : 'Unknown Agent',
                                text: `Query received: "${myQueryText}" (Coordinator routing...)`
                            });
                            // Simply echoing back for demonstration
                            this.mySendMessage(myMsg.senderId, 'COORDINATOR_ROUTING_ACK', { status: 'acknowledged' });
                        // }
                        break;

                    case 'AGENT_THOUGHT':
                    case 'TOOL_CALL':
                    case 'TOOL_RESULT':
                    case 'AGENT_RESPONSE':
                    case 'SENSOR_DATA': // New message type for sensor data
                        const myReportingAgent = this.myClients.get(myMsg.senderId);
                        const myAgentName = myReportingAgent ? myReportingAgent.name : myMsg.senderId;
                        this.myAddLog(`${myAgentName} (${myMsg.type}): ${JSON.stringify(myMsg.payload)}`);
                        // For this demo, we'll just broadcast these messages for visibility
                        this.myBroadcastMessageToClients('COORDINATOR_BROADCAST_MESSAGE', {
                            senderName: myAgentName,
                            text: `[${myMsg.type}]: ${JSON.stringify(myMsg.payload)}`
                        });
                        break;

                    case 'AGENT_DISCONNECT':
                        const myDisconnectedClientInfo = this.myClients.get(myMsg.senderId);
                        if (myDisconnectedClientInfo) {
                            this.myClients.delete(myMsg.senderId);
                            this.myAddLog(`Agent ${myDisconnectedClientInfo.id} (${myDisconnectedClientInfo.name}) disconnected.`);
                            this.myUpdateClientListAndNotify();
                            this.myBroadcastMessageToClients('COORDINATOR_DISCONNECTED_AGENT', { agentId: myDisconnectedClientInfo.id, agentName: myDisconnectedClientInfo.name });
                            this.myBroadcastMessageToClients('COORDINATOR_BROADCAST_MESSAGE', { senderName: 'Coordinator', text: `${myDisconnectedClientInfo.name} has left the agent swarm.` });
                        } else {
                            this.myAddLog(`Unknown agent ${myMsg.senderId} attempted to disconnect.`);
                        }
                        break;

                    case 'AGENT_PING':
                        // this.myAddLog(`Agent ${myMsg.senderId} responded to ping.`);
                        break;

                    default:
                        this.myAddLog(`Unknown message type received from agent ${myMsg.senderId}: ${myMsg.type}`);
                        break;
                }
            }

            myUpdateClientListAndNotify() {
                this.myClientUpdateListeners.forEach(myListener => myListener());
                const myClientList = Array.from(this.myClients.values()).map(myC => ({ id: myC.id, name: myC.name, status: myC.status }));
                this.myBroadcastMessageToClients('COORDINATOR_AGENT_LIST_UPDATE', { agents: myClientList });
            }

            myOnLog(myListener) {
                this.myLogListeners.push(myListener);
                return () => this.myLogListeners = this.myLogListeners.filter(myL => myL !== myListener);
            }

            myOnClientUpdate(myListener) {
                this.myClientUpdateListeners.push(myListener);
                return () => this.myClientUpdateListeners = this.myClientUpdateListeners.filter(myL => myL !== myListener);
            }

            myGetClients() {
                return Array.from(this.myClients.values()).map(myC => ({ id: myC.id, name: myC.name, status: myC.status }));
            }
        }

        // --- My Global DOM Utilities & Application Setup ---

        let myCoordinatorInstance;
        const myServerLogsDiv = document.getElementById('my-server-logs');
        const myClientListDiv = document.getElementById('my-client-list');
        const myConnectedClientsCountSpan = document.getElementById('my-connected-clients-count');
        const mySpawnClientButton = document.getElementById('my-spawn-client-button');

        function myAppendLog(myElement, myMessage) {
            const myP = document.createElement('p');
            myP.textContent = myMessage;
            myElement.appendChild(myP);
            myElement.scrollTop = myElement.scrollHeight;
        }

        function myUpdateServerClientList() {
            myClientListDiv.innerHTML = '';
            const myClients = myCoordinatorInstance.myGetClients();
            if (myClients.length === 0) {
                const myP = document.createElement('p');
                myP.style.color = 'gray';
                myP.style.fontStyle = 'italic';
                myP.textContent = 'No agents connected yet.';
                myClientListDiv.appendChild(myP);
            } else {
                myClients.forEach(myClient => {
                    const myP = document.createElement('p');
                    myP.classList.add('my-client-item');
                    myP.innerHTML = `<strong>${myClient.name}</strong> (ID: ${myClient.id.substring(0, 8)}...) - Status: ${myClient.status}`;
                    myClientListDiv.appendChild(myP);
                });
            }
            myConnectedClientsCountSpan.textContent = myClients.length;
        }

        function mySpawnNewClientTab() {
            // Open my_llm_agent_client.html in a new tab
            window.open('./my_llm_agent_client.html', '_blank', 'noopener');
        }

        // Initialize on window load
        window.onload = function() {
            myCoordinatorInstance = new MyAgentCoordinator();

            myCoordinatorInstance.myOnLog((myLog) => {
                myAppendLog(myServerLogsDiv, myLog);
            });

            myCoordinatorInstance.myOnClientUpdate(() => {
                myUpdateServerClientList();
            });

            mySpawnClientButton.addEventListener('click', mySpawnNewClientTab);

            myUpdateServerClientList(); // Initial list update
        };
    </script>
</body>
</html>
